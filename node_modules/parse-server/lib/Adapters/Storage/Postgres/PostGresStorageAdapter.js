'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var pgp = require('pg-promise')();

var PostgresRelationDoesNotExistError = '42P01';
var PostgresDuplicateRelationError = '42P07';

var parseTypeToPostgresType = function parseTypeToPostgresType(type) {
  switch (type.type) {
    case 'String':
      return 'text';
    case 'Date':
      return 'timestamp';
    case 'Object':
      return 'jsonb';
    case 'Boolean':
      return 'boolean';
    case 'Pointer':
      return 'char(10)';
    case 'Number':
      return 'double precision';
    case 'Array':
      if (type.contents && type.contents.type === 'String') {
        return 'text[]';
      } else {
        throw 'no type for ' + JSON.stringify(type) + ' yet';
      }
    default:
      throw 'no type for ' + JSON.stringify(type) + ' yet';
  }
};

var PostgresStorageAdapter = exports.PostgresStorageAdapter = function () {
  // Private

  function PostgresStorageAdapter(_ref) {
    var uri = _ref.uri;
    var _ref$collectionPrefix = _ref.collectionPrefix;
    var collectionPrefix = _ref$collectionPrefix === undefined ? '' : _ref$collectionPrefix;

    _classCallCheck(this, PostgresStorageAdapter);

    this._collectionPrefix = collectionPrefix;
    this._client = pgp(uri);
  }

  _createClass(PostgresStorageAdapter, [{
    key: '_ensureSchemaCollectionExists',
    value: function _ensureSchemaCollectionExists() {
      return this._client.query('CREATE TABLE "_SCHEMA" ( "className" varChar(120), "schema" jsonb, "isParseClass" bool, PRIMARY KEY ("className") )').catch(function (error) {
        if (error.code === PostgresDuplicateRelationError) {
          // Table already exists, must have been created by a different request. Ignore error.
          return;
        } else {
          throw error;
        }
      });
    }
  }, {
    key: 'classExists',
    value: function classExists(name) {
      var _this = this;

      console.log('classExists(name) {');
      return this.connect().then(function () {
        return _this.database.listCollections({ name: _this._collectionPrefix + name }).toArray();
      }).then(function (collections) {
        return collections.length > 0;
      });
    }
  }, {
    key: 'setClassLevelPermissions',
    value: function setClassLevelPermissions(className, CLPs) {
      console.log('setClassLevelPermissions(className, CLPs) {');
      return this._schemaCollection().then(function (schemaCollection) {
        return schemaCollection.updateSchema(className, {
          $set: { _metadata: { class_permissions: CLPs } }
        });
      });
    }
  }, {
    key: 'createClass',
    value: function createClass(className, schema) {
      var _this2 = this;

      var valuesArray = [];
      var patternsArray = [];
      Object.keys(schema.fields).forEach(function (fieldName, index) {
        valuesArray.push(fieldName);
        var parseType = schema.fields[fieldName];
        if (['_rperm', '_wperm'].includes(fieldName)) {
          parseType.contents = { type: 'String' };
        }
        valuesArray.push(parseTypeToPostgresType(parseType));
        patternsArray.push('$' + (index * 2 + 2) + ':name $' + (index * 2 + 3) + ':raw');
      });
      return this._client.query('CREATE TABLE $1:name (' + patternsArray.join(',') + ')', [className].concat(valuesArray)).then(function () {
        return _this2._client.query('INSERT INTO "_SCHEMA" ("className", "schema", "isParseClass") VALUES ($<className>, $<schema>, true)', { className: className, schema: schema });
      });
    }
  }, {
    key: 'addFieldIfNotExists',
    value: function addFieldIfNotExists(className, fieldName, type) {
      var _this3 = this;

      // TODO: Doing this in a transaction might be a good idea.
      return this._client.query('ALTER TABLE $<className:name> ADD COLUMN $<fieldName:name> $<postgresType:raw>', { className: className, fieldName: fieldName, postgresType: parseTypeToPostgresType(type) }).catch(function (error) {
        if (error.code === PostgresRelationDoesNotExistError) {
          return _this3.createClass(className, { fields: _defineProperty({}, fieldName, type) });
        } else {
          throw error;
        }
      }).then(function () {
        return _this3._client.query('SELECT "schema" FROM "_SCHEMA"', { className: className });
      }).then(function (result) {
        if (fieldName in result[0].schema) {
          throw "Attempted to add a field that already exists";
        } else {
          result[0].schema.fields[fieldName] = type;
          return _this3._client.query('UPDATE "_SCHEMA" SET "schema"=$<schema> WHERE "className"=$<className>', { schema: result[0].schema, className: className });
        }
      });
    }

    // Drops a collection. Resolves with true if it was a Parse Schema (eg. _User, Custom, etc.)
    // and resolves with false if it wasn't (eg. a join table). Rejects if deletion was impossible.

  }, {
    key: 'deleteClass',
    value: function deleteClass(className) {
      var _this4 = this;

      console.log('deleteClass(className) {');
      return this._adaptiveCollection(className).then(function (collection) {
        return collection.drop();
      }).catch(function (error) {
        // 'ns not found' means collection was already gone. Ignore deletion attempt.
        if (error.message == 'ns not found') {
          return;
        }
        throw error;
      })
      // We've dropped the collection, now remove the _SCHEMA document
      .then(function () {
        return _this4._schemaCollection();
      }).then(function (schemaCollection) {
        return schemaCollection.findAndDeleteSchema(className);
      });
    }

    // Delete all data known to this adatper. Used for testing.

  }, {
    key: 'deleteAllClasses',
    value: function deleteAllClasses() {
      var _this5 = this;

      return this._client.query('SELECT "className" FROM "_SCHEMA"').then(function (results) {
        var classes = ['_SCHEMA'].concat(_toConsumableArray(results.map(function (result) {
          return result.className;
        })));
        return Promise.all(classes.map(function (className) {
          return _this5._client.query('DROP TABLE $<className:name>', { className: className });
        }));
      }, function (error) {
        if (error.code === PostgresRelationDoesNotExistError) {
          // No _SCHEMA collection. Don't delete anything.
          return;
        } else {
          throw error;
        }
      });
    }

    // Remove the column and all the data. For Relations, the _Join collection is handled
    // specially, this function does not delete _Join columns. It should, however, indicate
    // that the relation fields does not exist anymore. In mongo, this means removing it from
    // the _SCHEMA collection.  There should be no actual data in the collection under the same name
    // as the relation column, so it's fine to attempt to delete it. If the fields listed to be
    // deleted do not exist, this function should return successfully anyways. Checking for
    // attempts to delete non-existent fields is the responsibility of Parse Server.

    // Pointer field names are passed for legacy reasons: the original mongo
    // format stored pointer field names differently in the database, and therefore
    // needed to know the type of the field before it could delete it. Future database
    // adatpers should ignore the pointerFieldNames argument. All the field names are in
    // fieldNames, they show up additionally in the pointerFieldNames database for use
    // by the mongo adapter, which deals with the legacy mongo format.

    // This function is not obligated to delete fields atomically. It is given the field
    // names in a list so that databases that are capable of deleting fields atomically
    // may do so.

    // Returns a Promise.

  }, {
    key: 'deleteFields',
    value: function deleteFields(className, schema, fieldNames) {
      var _this6 = this;

      console.log('deleteFields(className, schema, fieldNames) {');
      var mongoFormatNames = fieldNames.map(function (fieldName) {
        if (schema.fields[fieldName].type === 'Pointer') {
          return '_p_' + fieldName;
        } else {
          return fieldName;
        }
      });
      var collectionUpdate = { '$unset': {} };
      mongoFormatNames.forEach(function (name) {
        collectionUpdate['$unset'][name] = null;
      });

      var schemaUpdate = { '$unset': {} };
      fieldNames.forEach(function (name) {
        schemaUpdate['$unset'][name] = null;
      });

      return this._adaptiveCollection(className).then(function (collection) {
        return collection.updateMany({}, collectionUpdate);
      }).then(function () {
        return _this6._schemaCollection();
      }).then(function (schemaCollection) {
        return schemaCollection.updateSchema(className, schemaUpdate);
      });
    }

    // Return a promise for all schemas known to this adapter, in Parse format. In case the
    // schemas cannot be retrieved, returns a promise that rejects. Rquirements for the
    // rejection reason are TBD.

  }, {
    key: 'getAllClasses',
    value: function getAllClasses() {
      var _this7 = this;

      return this._ensureSchemaCollectionExists().then(function () {
        return _this7._client.query('SELECT * FROM "_SCHEMA"');
      }).then(function (results) {
        return results.map(function (result) {
          return _extends({ className: result.className }, result.schema);
        });
      });
    }

    // Return a promise for the schema with the given name, in Parse format. If
    // this adapter doesn't know about the schema, return a promise that rejects with
    // undefined as the reason.

  }, {
    key: 'getClass',
    value: function getClass(className) {
      return this._client.query('SELECT * FROM "_SCHEMA" WHERE "className"=$<className>', { className: className }).then(function (result) {
        if (result.length === 1) {
          return result[0];
        } else {
          throw undefined;
        }
      });
    }

    // TODO: remove the mongo format dependency in the return value

  }, {
    key: 'createObject',
    value: function createObject(className, schema, object) {
      var columnsArray = [];
      var valuesArray = [];
      Object.keys(object).forEach(function (fieldName) {
        columnsArray.push(fieldName);
        switch (schema.fields[fieldName].type) {
          case 'Date':
            valuesArray.push(object[fieldName].iso);
            break;
          case 'Pointer':
            valuesArray.push(object[fieldName].objectId);
            break;
          default:
            valuesArray.push(object[fieldName]);
            break;
        }
      });
      var columnsPattern = columnsArray.map(function (col, index) {
        return '$' + (index + 2) + ':name';
      }).join(',');
      var valuesPattern = valuesArray.map(function (val, index) {
        return '$' + (index + 2 + columnsArray.length);
      }).join(',');
      return this._client.query('INSERT INTO $1:name (' + columnsPattern + ') VALUES (' + valuesPattern + ')', [className].concat(columnsArray, valuesArray)).then(function () {
        return { ops: [object] };
      });
    }

    // Remove all objects that match the given Parse Query.
    // If no objects match, reject with OBJECT_NOT_FOUND. If objects are found and deleted, resolve with undefined.
    // If there is some other error, reject with INTERNAL_SERVER_ERROR.

  }, {
    key: 'deleteObjectsByQuery',
    value: function deleteObjectsByQuery(className, schema, query) {
      return this._client.query('WITH deleted AS (DELETE FROM $<className:name> RETURNING *) SELECT count(*) FROM deleted', { className: className }).then(function (result) {
        if (result[0].count === 0) {
          throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, 'Object not found.');
        } else {
          return result[0].count;
        }
      });
    }

    // Apply the update to all objects that match the given Parse Query.

  }, {
    key: 'updateObjectsByQuery',
    value: function updateObjectsByQuery(className, schema, query, update) {
      console.log('updateObjectsByQuery(className, schema, query, update) {');
      var mongoUpdate = transformUpdate(className, update, schema);
      var mongoWhere = transformWhere(className, query, schema);
      return this._adaptiveCollection(className).then(function (collection) {
        return collection.updateMany(mongoWhere, mongoUpdate);
      });
    }

    // Return value not currently well specified.

  }, {
    key: 'findOneAndUpdate',
    value: function findOneAndUpdate(className, schema, query, update) {
      var conditionPatterns = [];
      var updatePatterns = [];
      var values = [];
      values.push(className);
      var index = 2;

      for (var fieldName in update) {
        var fieldValue = update[fieldName];
        if (fieldValue.__op === 'Increment') {
          updatePatterns.push('$' + index + ':name = COALESCE($' + index + ':name, 0) + $' + (index + 1));
          values.push(fieldName, fieldValue.amount);
          index += 2;
        } else if (fieldName === 'updatedAt') {
          //TODO: stop special casing this. It should check for __type === 'Date' and use .iso
          updatePatterns.push('$' + index + ':name = $' + (index + 1));
          values.push(fieldName, new Date(fieldValue));
          index += 2;
        } else {
          return Promise.reject(new Parse.Error(Parse.Error.OPERATION_FORBIDDEN, 'Postgres doesn\'t support this type of update yet'));
        }
      }

      for (var _fieldName in query) {
        var _fieldValue = query[_fieldName];
        if (typeof _fieldValue === 'string') {
          conditionPatterns.push('$' + index + ':name = $' + (index + 1));
          values.push(_fieldName, _fieldValue);
          index += 2;
        } else if (Array.isArray(_fieldValue.$in)) {
          (function () {
            var inPatterns = [];
            values.push(_fieldName);
            _fieldValue.$in.forEach(function (listElem, listIndex) {
              values.push(listElem);
              inPatterns.push('$' + (index + 1 + listIndex));
            });
            conditionPatterns.push('$' + index + ':name && ARRAY[' + inPatterns.join(',') + ']');
            index = index + 1 + inPatterns.length;
          })();
        } else {
          return Promise.reject(new Parse.Error(Parse.Error.OPERATION_FORBIDDEN, 'Postgres doesn\'t support this type of request yet'));
        }
      }
      var qs = 'UPDATE $1:name SET ' + updatePatterns.join(',') + ' WHERE ' + conditionPatterns.join(' AND ') + ' RETURNING *';
      return this._client.query(qs, values).then(function (val) {
        return val[0];
      });
    }

    // Hopefully we can get rid of this. It's only used for config and hooks.

  }, {
    key: 'upsertOneObject',
    value: function upsertOneObject(className, schema, query, update) {
      console.log('upsertOneObject(className, schema, query, update) {');
      var mongoUpdate = transformUpdate(className, update, schema);
      var mongoWhere = transformWhere(className, query, schema);
      return this._adaptiveCollection(className).then(function (collection) {
        return collection.upsertOne(mongoWhere, mongoUpdate);
      });
    }

    // Executes a find. Accepts: className, query in Parse format, and { skip, limit, sort }.

  }, {
    key: 'find',
    value: function find(className, schema, query, _ref2) {
      var skip = _ref2.skip;
      var limit = _ref2.limit;
      var sort = _ref2.sort;

      var conditionPatterns = [];
      var values = [];
      values.push(className);
      var index = 2;

      for (var fieldName in query) {
        var fieldValue = query[fieldName];
        if (typeof fieldValue === 'string') {
          conditionPatterns.push('$' + index + ':name = $' + (index + 1));
          values.push(fieldName, fieldValue);
          index += 2;
        } else if (fieldValue.$ne) {
          conditionPatterns.push('$' + index + ':name <> $' + (index + 1));
          values.push(fieldName, fieldValue.$ne);
          index += 2;
        } else if (Array.isArray(fieldValue.$in)) {
          (function () {
            var inPatterns = [];
            values.push(fieldName);
            fieldValue.$in.forEach(function (listElem, listIndex) {
              values.push(listElem);
              inPatterns.push('$' + (index + 1 + listIndex));
            });
            conditionPatterns.push('$' + index + ':name IN (' + inPatterns.join(',') + ')');
            index = index + 1 + inPatterns.length;
          })();
        } else if (fieldValue.__type === 'Pointer') {
          conditionPatterns.push('$' + index + ':name = $' + (index + 1));
          values.push(fieldName, fieldValue.objectId);
          index += 2;
        } else {
          return Promise.reject(new Parse.Error(Parse.Error.OPERATION_FORBIDDEN, "Postgres doesn't support this query type yet"));
        }
      }

      return this._client.query('SELECT * FROM $1:name WHERE ' + conditionPatterns.join(' AND '), values).then(function (results) {
        return results.map(function (object) {
          Object.keys(schema.fields).filter(function (field) {
            return schema.fields[field].type === 'Pointer';
          }).forEach(function (fieldName) {
            object[fieldName] = { objectId: object[fieldName], __type: 'Pointer', className: schema.fields[fieldName].targetClass };
          });
          //TODO: remove this reliance on the mongo format. DB adapter shouldn't know there is a difference between created at and any other date field.
          if (object.createdAt) {
            object.createdAt = object.createdAt.toISOString();
          }
          if (object.updatedAt) {
            object.updatedAt = object.updatedAt.toISOString();
          }
          if (object.expiresAt) {
            object.expiresAt = { __type: 'Date', iso: object.expiresAt.toISOString() };
          }

          for (var _fieldName2 in object) {
            if (object[_fieldName2] === null) {
              delete object[_fieldName2];
            }
          }

          return object;
        });
      });
    }

    // Create a unique index. Unique indexes on nullable fields are not allowed. Since we don't
    // currently know which fields are nullable and which aren't, we ignore that criteria.
    // As such, we shouldn't expose this function to users of parse until we have an out-of-band
    // Way of determining if a field is nullable. Undefined doesn't count against uniqueness,
    // which is why we use sparse indexes.

  }, {
    key: 'ensureUniqueness',
    value: function ensureUniqueness(className, schema, fieldNames) {
      console.log('ensureUniqueness(className, schema, fieldNames) {');
      return Promise.resolve();
      var indexCreationRequest = {};
      var mongoFieldNames = fieldNames.map(function (fieldName) {
        return transformKey(className, fieldName, schema);
      });
      mongoFieldNames.forEach(function (fieldName) {
        indexCreationRequest[fieldName] = 1;
      });
      return this._adaptiveCollection(className).then(function (collection) {
        return collection._ensureSparseUniqueIndexInBackground(indexCreationRequest);
      }).catch(function (error) {
        if (error.code === 11000) {
          throw new Parse.Error(Parse.Error.DUPLICATE_VALUE, 'Tried to ensure field uniqueness for a class that already has duplicates.');
        } else {
          throw error;
        }
      });
    }

    // Executs a count.

  }, {
    key: 'count',
    value: function count(className, schema, query) {
      console.log('count(className, schema, query) {');
      return this._adaptiveCollection(className).then(function (collection) {
        return collection.count(transformWhere(className, query, schema));
      });
    }
  }]);

  return PostgresStorageAdapter;
}();

exports.default = PostgresStorageAdapter;

module.exports = PostgresStorageAdapter; // Required for tests